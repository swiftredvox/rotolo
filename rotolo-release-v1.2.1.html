<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rotolo</title>
  <style>
    :root{
      --bgA: #0b1020;
      --bgB: #101a3a;
      --bgAccent: rgba(122,162,255,0.06);
      --hexStroke: #a9c1ff;
      --text: #e6eef9;
      --muted: #97a3b6;
      --panel: #0f1530;
      --shadow: rgba(0,0,0,0.35);
      --ui-accent: #7aa2ff;
      --ui-good: #70e27e;
      --ui-warn: #ffcf5a;
      --select-bg: #0f1530;
      --select-bg-hover: #131b3a;
      --select-border: rgba(255,255,255,0.22);
      --select-border-hover: rgba(255,255,255,0.34);
      --select-option-bg: #0f1530;
      --select-option-color: #e6eef9;
      --select-option-hover: #1c244a;
      color-scheme: dark;
    }
    html, body {
      height: 100%;
      margin: 0;
      background:
        radial-gradient(1200px 900px at 70% 20%, var(--bgB) 0%, var(--bgA) 60%),
        radial-gradient(900px 700px at 25% 85%, var(--bgAccent) 0%, transparent 65%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow: hidden;
    }
    .wrap { display: grid; grid-template-columns: 330px 1fr; height: 100%; }
    .panel {
      padding: 18px 16px 24px 18px;
      background: linear-gradient(170deg, var(--panel), #0b1330 130%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.035), inset 0 0 0 1px rgba(255,255,255,0.03), 10px 0 30px var(--shadow);
      overflow-y:auto;
    }
    .h1 { font-size: 20px; font-weight: 800; letter-spacing: 0.2px; margin: 4px 0 8px; }
    .group { margin-bottom: 14px; }
    .group h3 { margin: 12px 0 6px; font-size: 12px; color: var(--muted); letter-spacing: .15em; text-transform: uppercase; font-weight: 800;}
    .row { display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin:8px 0;}
    .row label { font-size:14px; color:#eaf2ff; }
    .row input[type=range]{ width: 170px; accent-color: var(--ui-accent); }
    .value{ font-variant-numeric: tabular-nums; color:#8be2ff; padding:2px 6px; border-radius:8px; background: rgba(110,231,240,0.08); border:1px solid rgba(110,231,240,0.2);}
    .select { display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin: 8px 0; position: relative; }

    /* Cross‑browser readable select */
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background: var(--select-bg);
      color: var(--text);
      border: 1px solid var(--select-border);
      padding: 8px 28px 8px 10px;
      border-radius: 10px;
      font-weight: 700;
      line-height: 1.2;
    }
    select:hover { border-color: var(--select-border-hover); background: var(--select-bg-hover); }
    select:focus { outline: none; border-color: var(--select-border-hover); box-shadow: 0 0 0 3px rgba(122,162,255,0.25); }
    select option {
      background-color: var(--select-option-bg);
      color: var(--select-option-color);
    }
    select option:checked, select option:hover {
      background-color: var(--select-option-hover);
      color: var(--select-option-color);
    }
    select::-ms-expand { display: none; }

    .select:after { content: "▾"; position: absolute; right: 10px; color: #cfe5ff; pointer-events: none; top: 50%; transform: translateY(-50%); }

    .btns{ display:grid; grid-template-columns: repeat(2,1fr); gap:8px; margin-top:10px;}
    .btn{ cursor:pointer; border:none; padding:10px 10px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); color:#f2f6ff;
      box-shadow:0 2px 10px var(--shadow), inset 0 0 0 1px rgba(255,255,255,.06); transition: transform .12s ease, box-shadow .2s ease;
      font-weight:800; font-size:13px; letter-spacing: .2px;}
    .btn:hover{ transform: translateY(-1px); box-shadow:0 6px 16px var(--shadow), inset 0 0 0 1px rgba(255,255,255,.09);}
    .btn.accent{ background: linear-gradient(180deg, rgba(122,162,255,.25), rgba(122,162,255,.08)); }
    .btn.good{ background: linear-gradient(180deg, rgba(112,226,126,.25), rgba(112,226,126,.08)); }
    .btn.warn{ background: linear-gradient(180deg, rgba(255,207,90,.25), rgba(255,207,90,.08)); }
    .canvas-wrap{ position:relative; }
    canvas{ width:100%; height:100%; display:block; }
    .overlay{ position:absolute; left:12px; bottom:12px; padding:6px 10px; border-radius:10px; background: rgba(0,0,0,.25); color:#cfe5ff; font-size:12px; font-variant-numeric: tabular-nums; pointer-events:none; user-select:none; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);}
  </style>
</head>
<body>
  <div class="wrap">
    <aside class="panel">
      <div class="h1">Rotolo</div>

      <div class="group">
        <h3>Simulation</h3>
        <div class="row">
          <label for="count">Ball Count</label>
          <input id="count" type="range" min="1" max="80" step="1" value="20" />
          <span class="value" id="countV">20</span>
        </div>
        <div class="row">
          <label for="gravity">Gravity (px/s²)</label>
          <input id="gravity" type="range" min="-2000" max="2000" step="10" value="700" />
          <span class="value" id="gravityV">700</span>
        </div>
        <div class="row">
          <label for="air">Air Drag</label>
          <input id="air" type="range" min="0" max="0.1" step="0.001" value="0.010" />
          <span class="value" id="airV">0.010</span>
        </div>
        <div class="row">
          <label for="rest">Bounciness</label>
          <input id="rest" type="range" min="0" max="1" step="0.01" value="0.70" />
          <span class="value" id="restV">70%</span>
        </div>
        <div class="row">
          <label for="rot">Rotation Speed</label>
          <input id="rot" type="range" min="-100" max="100" step="1" value="25" />
          <span class="value" id="rotV">25%</span>
        </div>
        <div class="row">
          <label for="radius">Hex Size</label>
          <input id="radius" type="range" min="120" max="1000" step="1" value="320" />
          <span class="value" id="radiusV">320</span>
        </div>
        <div class="row">
          <label for="minr">Min Ball Size</label>
          <input id="minr" type="range" min="15" max="40" step="1" value="25" />
          <span class="value" id="minrV">25</span>
        </div>
        <div class="row">
          <label for="maxr">Max Ball Size</label>
          <input id="maxr" type="range" min="15" max="40" step="1" value="25" />
          <span class="value" id="maxrV">25</span>
        </div>
        <div class="select">
          <label for="overlay">Overlay</label>
          <select id="overlay">
            <option value="off" selected>Off</option>
            <option value="numbers">Numbers</option>
            <option value="faces">Faces</option>
            <option value="velocity">Velocity</option>
          </select>
        </div>
      </div>

      <div class="group">
        <h3>Style</h3>
        <div class="select">
          <label for="theme">Theme</label>
          <select id="theme">
            <option value="neon" selected>Neon</option>
            <option value="aurora">Aurora</option>
            <option value="sunset">Sunset</option>
            <option value="mono">Mono</option>
            <option value="ocean">Ocean</option>
            <option value="candy">Candy</option>
            <option value="citrus">Citrus</option>
            <option value="ember">Ember</option>
          </select>
        </div>
        <div class="row">
          <label for="glow">Glow</label>
          <input id="glow" type="range" min="0" max="1" step="0.05" value="0.6" />
          <span class="value" id="glowV">60%</span>
        </div>
        <div class="btns">
          <button id="defaults" class="btn">Defaults</button>
          <button id="pause" class="btn accent">Pause</button>
          <button id="reset" class="btn warn">Reset</button>
          <button id="randomize" class="btn good">Randomize</button>
        </div>
      </div>
    </aside>

    <main class="canvas-wrap">
      <canvas id="c"></canvas>
      <div class="overlay" id="stats">0 fps</div>
    </main>
  </div>

  <script>
    // ===== Canvas =====
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W=0,H=0,DPR=Math.max(1, window.devicePixelRatio||1);
    function resize(){const r=canvas.parentElement.getBoundingClientRect(); W=Math.floor(r.width*DPR); H=Math.floor(r.height*DPR); canvas.width=W; canvas.height=H;}
    window.addEventListener('resize', resize); resize();

    const center = ()=>({cx: W/2, cy: H/2});

    // ===== State =====
    let balls=[]; let hexAngle=0; let currentHexVerts=[]; let paused=false;

    // ===== UI =====
    const $ = (id)=>document.getElementById(id);
    const ui = {
      count: $('count'), countV: $('countV'),
      gravity: $('gravity'), gravityV: $('gravityV'),
      air: $('air'), airV: $('airV'),
      rest: $('rest'), restV: $('restV'),
      rot: $('rot'), rotV: $('rotV'),
      radius: $('radius'), radiusV: $('radiusV'),
      minr: $('minr'), minrV: $('minrV'),
      maxr: $('maxr'), maxrV: $('maxrV'),
      overlay: $('overlay'),
      theme: $('theme'),
      glow: $('glow'), glowV: $('glowV'),
      defaults: $('defaults'),
      pause: $('pause'),
      reset: $('reset'),
      randomize: $('randomize')
    };
    function bindRange(range, label, fmt=(v)=>v){ const set=()=>label.textContent=fmt(range.value); range.addEventListener('input',set); set();}
    bindRange(ui.count, ui.countV);
    bindRange(ui.gravity, ui.gravityV);
    bindRange(ui.air, ui.airV, v=>Number(v).toFixed(3));
    bindRange(ui.rest, ui.restV, v=>Math.round(Number(v)*100)+'%');
    bindRange(ui.rot, ui.rotV, v=>Math.round(Number(v))+'%');
    bindRange(ui.radius, ui.radiusV);
    bindRange(ui.minr, ui.minrV);
    bindRange(ui.maxr, ui.maxrV);
    bindRange(ui.glow, ui.glowV, v=>Math.round(Number(v)*100)+'%');

    const statsEl=$('stats');
    let lastFpsT=performance.now(), frames=0;
    function updateFps(now){ frames++; if(now-lastFpsT>=500){ const fps=Math.round(frames*1000/(now-lastFpsT)); statsEl.textContent=fps+' fps · '+balls.length+' balls'; frames=0; lastFpsT=now; }}

    // ===== Helpers =====
    const rand=(a,b)=>a+Math.random()*(b-a);
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const ROT_DEG_PER_PERCENT = 1.2; // 100% == 120°/s
    const percentToRadPerSec=(p)=>(Number(p)*ROT_DEG_PER_PERCENT)*Math.PI/180;

    // ===== Themes =====
    const THEMES = {
      neon:   { bgA:'#0b1020', bgB:'#101a3a', bgAccent:'rgba(122,162,255,0.06)', hex:'#a9c1ff', glow:'#7aa2ff', hueRanges:[[190,260]], sat:[60,85], lit:[55,70] },
      aurora: { bgA:'#071b1a', bgB:'#0b1020', bgAccent:'rgba(38,224,180,0.06)', hex:'#6ef7d6', glow:'#4ee9c7', hueRanges:[[150,190],[260,290]], sat:[55,80], lit:[55,70] },
      sunset: { bgA:'#140d10', bgB:'#0b0a14', bgAccent:'rgba(255,150,120,0.06)', hex:'#ff9ed2', glow:'#ff7bb0', hueRanges:[[10,40],[330,355]], sat:[65,90], lit:[55,70] },
      mono:   { bgA:'#0d0f14', bgB:'#080b12', bgAccent:'rgba(180,190,200,0.06)', hex:'#d7e1ef', glow:'#d0d9e6', hueRanges:[[210,230]], sat:[8,18],  lit:[70,85] },
      ocean:  { bgA:'#04141e', bgB:'#071a24', bgAccent:'rgba(100,200,255,0.06)', hex:'#7ed3ff', glow:'#6ac8ff', hueRanges:[[190,215],[200,230]], sat:[55,80], lit:[60,75] },
      candy:  { bgA:'#1a0c17', bgB:'#120a14', bgAccent:'rgba(255,120,200,0.07)', hex:'#ffb5e5', glow:'#ff8fd3', hueRanges:[[300,330],[0,20]], sat:[65,90], lit:[65,78] },
      citrus: { bgA:'#141006', bgB:'#0b0d08', bgAccent:'rgba(255,230,120,0.06)', hex:'#ffe089', glow:'#ffd35a', hueRanges:[[35,55],[70,95]], sat:[60,85], lit:[60,75] },
      ember:  { bgA:'#180b0a', bgB:'#0f0a0a', bgAccent:'rgba(255,120,80,0.06)', hex:'#ffad8a', glow:'#ff8b63', hueRanges:[[8,18],[12,24]], sat:[60,85], lit:[58,72] }
    };
    function chooseHue(ranges){ const bucket=ranges[Math.floor(Math.random()*ranges.length)]; return rand(bucket[0], bucket[1]); }
    const themeState = {hex: THEMES.neon.hex, glow: THEMES.neon.glow, hueRanges: THEMES.neon.hueRanges, sat: THEMES.neon.sat, lit: THEMES.neon.lit};
    function applyTheme(key){
      const t = THEMES[key] || THEMES.neon;
      const root = document.documentElement;
      root.style.setProperty('--bgA', t.bgA);
      root.style.setProperty('--bgB', t.bgB);
      root.style.setProperty('--bgAccent', t.bgAccent);
      root.style.setProperty('--hexStroke', t.hex);
      for(const b of balls){ b.hue = chooseHue(t.hueRanges); b.sat = Math.floor(rand(t.sat[0], t.sat[1])); b.lit = Math.floor(rand(t.lit[0], t.lit[1])); }
      themeState.hex=t.hex; themeState.glow=t.glow; themeState.hueRanges=t.hueRanges; themeState.sat=t.sat; themeState.lit=t.lit;
    }

    // ===== Physics =====
    class Ball{
      constructor(id,x,y,sizeT=Math.random(),vx=0,vy=0){
        this.id=id; this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.sizeT = clamp(sizeT,0,1); this.r=1; this.mass=1;
        this.hue = chooseHue(themeState.hueRanges);
        this.sat = Math.floor(rand(themeState.sat[0], themeState.sat[1]));
        this.lit = Math.floor(rand(themeState.lit[0], themeState.lit[1]));
        // Smoothed velocity for overlay stability
        this.svx = vx; this.svy = vy;
        this.smag = Math.hypot(vx,vy);
      }
      updateRadius(p){ this.r = lerp(p.minR, p.maxR, this.sizeT); this.mass = Math.PI*this.r*this.r; }
      color(a=1){ return `hsl(${this.hue} ${this.sat}% ${this.lit}% / ${a})`; }
      step(dt,p){
        this.vy += p.gravity*dt;
        const drag=1-clamp(p.air,0,1);
        this.vx*=drag; this.vy*=drag;
        this.x+=this.vx*dt; this.y+=this.vy*dt;
        // Exponential smoothing of velocity for overlays only (does not affect physics)
        const tau = 0.14; // seconds to follow changes, higher = smoother
        const a = 1 - Math.exp(-dt / tau);
        this.svx += (this.vx - this.svx) * a;
        this.svy += (this.vy - this.svy) * a;
        const curSmag = Math.hypot(this.svx, this.svy);
        this.smag += (curSmag - this.smag) * a;
      }
      draw(ctx, overlay='off', glowK=0.6){
        ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
        const g=ctx.createRadialGradient(this.x-this.r*0.45,this.y-this.r*0.45,this.r*0.3,this.x,this.y,this.r);
        g.addColorStop(0,this.color(0.95)); g.addColorStop(1,this.color(0.55));
        ctx.fillStyle=g;
        const speed = Math.hypot(this.vx,this.vy);
        const k = clamp(glowK + speed*0.0007, 0, 1.2);
        ctx.shadowBlur = this.r * 0.9 * k;
        ctx.shadowColor = this.color(0.8);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth=1.2*DPR; ctx.strokeStyle=`hsl(${this.hue} ${this.sat}% ${Math.max(20,this.lit-30)}% / 0.7)`; ctx.stroke();

        // Overlays (use smoothed velocity to reduce jitter)
        if(overlay === 'numbers'){
          ctx.fillStyle='rgba(8,12,24,0.85)';
          ctx.font=`${Math.max(10,Math.floor(this.r*0.95))}px ui-sans-serif, system-ui`;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(this.id,this.x,this.y+0.5);
        } else if(overlay === 'faces'){
          const ang = Math.atan2(this.svy, this.svx);
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(ang*0.35);
          const eyeR = Math.max(1.2*DPR, this.r*0.12);
          const eyeX = this.r*0.35, eyeY = -this.r*0.15;
          ctx.fillStyle = 'rgba(8,12,24,0.85)';
          ctx.beginPath(); ctx.arc(-eyeX, eyeY, eyeR, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc( eyeX, eyeY, eyeR, 0, Math.PI*2); ctx.fill();
          const mW = this.r*0.7, mY = this.r*0.25, mH = Math.max(1*DPR, this.r*0.08);
          ctx.beginPath();
          ctx.lineWidth = mH;
          ctx.lineCap = 'round';
          ctx.strokeStyle = 'rgba(8,12,24,0.85)';
          ctx.moveTo(-mW*0.35, mY);
          ctx.quadraticCurveTo(0, mY+this.r*0.12, mW*0.35, mY);
          ctx.stroke();
          ctx.restore();
        } else if(overlay === 'velocity'){
          const smag = this.smag;
          if(smag > 0.5){
            const ang = Math.atan2(this.svy, this.svx);
            const lenTarget = Math.min(this.r*0.9 + smag*0.03, this.r*2.0);
            const len = lenTarget; // already smoothed via smag
            const tailX = this.x - Math.cos(ang)*len*0.6;
            const tailY = this.y - Math.sin(ang)*len*0.6;
            const headX = this.x + Math.cos(ang)*len*0.4;
            const headY = this.y + Math.sin(ang)*len*0.4;
            ctx.strokeStyle = 'rgba(8,12,24,0.85)';
            ctx.lineWidth = Math.max(1*DPR, this.r*0.08);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(tailX, tailY);
            ctx.lineTo(headX, headY);
            ctx.stroke();
            const ah = Math.max(2*DPR, this.r*0.18);
            const leftX = headX - Math.cos(ang - Math.PI/6)*ah;
            const leftY = headY - Math.sin(ang - Math.PI/6)*ah;
            const rightX= headX - Math.cos(ang + Math.PI/6)*ah;
            const rightY= headY - Math.sin(ang + Math.PI/6)*ah;
            ctx.beginPath();
            ctx.moveTo(headX, headY);
            ctx.lineTo(leftX, leftY);
            ctx.moveTo(headX, headY);
            ctx.lineTo(rightX, rightY);
            ctx.stroke();
          }
        }
      }
    }
    function regularPolygon(cx,cy,R,n,a){ const pts=[]; for(let i=0;i<n;i++){ const t=a + i*(Math.PI*2/n); pts.push({x:cx+Math.cos(t)*R, y:cy+Math.sin(t)*R});} return pts; }
    function pointLine(px,py,ax,ay,bx,by){ const abx=bx-ax, aby=by-ay; const apx=px-ax, apy=py-ay; const ab2=abx*abx+aby*aby||1e-12; let t=(apx*abx+apy*aby)/ab2; t=clamp(t,0,1); const cx=ax+abx*t, cy=ay+aby*t; const nx=aby, ny=-abx; const nlen=Math.hypot(nx,ny)||1e-12; return {cx,cy,unx:nx/nlen,uny:ny/nlen}; }

    const params = {
      gravity:Number(ui.gravity.value),
      air:Number(ui.air.value),
      rest:Number(ui.rest.value),
      hexRotSpeed: percentToRadPerSec(ui.rot.value),
      hexRadius:Number(ui.radius.value)*DPR,
      minR:Number(ui.minr.value)*DPR,
      maxR:Number(ui.maxr.value)*DPR,
      overlay: ui.overlay.value,
      glow:Number(ui.glow.value),
    };

    function syncParamsFromUI(){
      params.gravity=Number(ui.gravity.value);
      params.air=Number(ui.air.value);
      params.rest=Number(ui.rest.value);
      params.hexRotSpeed=percentToRadPerSec(ui.rot.value);
      params.hexRadius=Number(ui.radius.value)*DPR;
      params.minR=Number(ui.minr.value)*DPR;
      params.maxR=Math.max(params.minR, Number(ui.maxr.value)*DPR);
      params.overlay=ui.overlay.value;
      params.glow=Number(ui.glow.value);
      rescaleBallSizes();
      setBallCount(Number(ui.count.value));
    }
    ['gravity','air','rest','rot','radius','glow'].forEach(id=> ui[id].addEventListener('input', syncParamsFromUI));
    ui.overlay.addEventListener('change', syncParamsFromUI);
    ui.minr.addEventListener('input', ()=>{ if(Number(ui.minr.value)>Number(ui.maxr.value)){ ui.maxr.value=ui.minr.value; ui.maxr.dispatchEvent(new Event('input')); } syncParamsFromUI(); });
    ui.maxr.addEventListener('input', ()=>{ if(Number(ui.maxr.value)<Number(ui.minr.value)){ ui.minr.value=ui.maxr.value; ui.minr.dispatchEvent(new Event('input')); } syncParamsFromUI(); });
    ui.count.addEventListener('input', syncParamsFromUI);
    ui.theme.addEventListener('change', ()=>applyTheme(ui.theme.value));

    function rescaleBallSizes(){ for(const b of balls){ b.updateRadius(params); } }

    // Defaults
    ui.defaults.addEventListener('click',()=>{
      ui.count.value=20; ui.gravity.value=700; ui.air.value=0.010; ui.rest.value=0.70; ui.rot.value=25; ui.radius.value=320; ui.minr.value=25; ui.maxr.value=25;
      ui.overlay.value='off';
      ui.theme.value='neon'; ui.glow.value=0.6;
      ['count','gravity','air','rest','rot','radius','minr','maxr','glow'].forEach(id=> ui[id].dispatchEvent(new Event('input')));
      ui.overlay.dispatchEvent(new Event('change'));
      resetAll(); applyTheme('neon');
    });

    // Interactions
    let mouse={x:0,y:0};
    canvas.addEventListener('mousemove',e=>{ const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)*DPR; mouse.y=(e.clientY-r.top)*DPR; });
    canvas.addEventListener('mousedown',e=>{
      if(e.button===2){
        const current=Number(ui.count.value);
        if(current<Number(ui.count.max)){ spawnBall(mouse.x,mouse.y); ui.count.value=current+1; ui.count.dispatchEvent(new Event('input')); }
      } else {
        for(const b of balls){ const dx=b.x-mouse.x, dy=b.y-mouse.y; const d2=dx*dx+dy*dy; if(d2<(b.r+80*DPR)**2){ const d=Math.sqrt(d2)||1; const ux=dx/d, uy=dy/d; const power=220*DPR; b.vx+=ux*power; b.vy+=uy*power; } }
      }
    });
    canvas.addEventListener('contextmenu',e=>e.preventDefault());
    canvas.addEventListener('wheel',e=>{ ui.radius.value=String(clamp(Number(ui.radius.value)+(e.deltaY<0?10:-10), Number(ui.radius.min), Number(ui.radius.max))); ui.radius.dispatchEvent(new Event('input')); }, {passive:true});

    // Creation & management
    function spawnBall(x,y){ const id=balls.length? Math.max(...balls.map(b=>b.id))+1:1; const sizeT=Math.random(); const b=new Ball(id,x,y,sizeT,rand(-60,60),rand(-60,60)); b.updateRadius(params); balls.push(b); return b; }
    function setBallCount(n){ const t=n|0; while(balls.length<t){ const {cx,cy}=center(); const ang=rand(0,Math.PI*2); const rad=rand(0, params.hexRadius*0.6); spawnBall(cx+Math.cos(ang)*rad, cy+Math.sin(ang)*rad); } while(balls.length>t) balls.pop(); for(let i=0;i<balls.length;i++) balls[i].id=i+1; }

    // Collisions
    function resolveCirclePoint(b,px,py,rest){ const dx=b.x-px, dy=b.y-py; let d=Math.hypot(dx,dy)||1e-6; const pen=b.r-d+1e-6; const nx=dx/d, ny=dy/d; b.x+=nx*pen; b.y+=ny*pen; const vn=b.vx*nx+b.vy*ny; const vtx=b.vx - vn*nx; const vty=b.vy - vn*ny; b.vx=vtx - vn*nx*rest; b.vy=vty - vn*ny*rest; }
    function collideBallWithPolygon(b, verts, rest){
      for(let i=0;i<verts.length;i++){
        const a=verts[i], c=verts[(i+1)%verts.length];
        const info=pointLine(b.x,b.y,a.x,a.y,c.x,c.y);
        const nx=info.unx, ny=info.uny;
        const signed=(b.x-a.x)*nx + (b.y-a.y)*ny;
        if(signed>-b.r){
          const cx=info.cx, cy=info.cy;
          const d=Math.hypot(b.x-cx,b.y-cy);
          if(d<b.r+1e-6){
            const pen=b.r-d+1e-6;
            const inx=-nx, iny=-ny;
            b.x+=inx*pen; b.y+=iny*pen;
            const vn=b.vx*inx + b.vy*iny;
            const vtx=b.vx - vn*inx; const vty=b.vy - vn*iny;
            b.vx = vtx - vn*inx*rest; b.vy = vty - vn*iny*rest;
          } else {
            const dA=Math.hypot(b.x-a.x);
            const dC=Math.hypot(b.x-c.x);
            if(dA<b.r) resolveCirclePoint(b,a.x,a.y,rest);
            else if(dC<b.r) resolveCirclePoint(b,c.x,c.y,rest);
          }
        }
      }
    }
    function resolveBallBall(a,b,rest){
      const dx=b.x-a.x, dy=b.y-a.y; const d2=dx*dx+dy*dy; const r=a.r+b.r; if(d2>=r*r || d2===0) return;
      const d=Math.sqrt(d2); const nx=dx/d, ny=dy/d; const pen=r-d; const tm=a.mass+b.mass; const ca=pen*(b.mass/tm), cb=pen*(a.mass/tm);
      a.x-=nx*ca; a.y-=ny*ca; b.x+=nx*cb; b.y+=ny*cb;
      const rvx=b.vx-a.vx, rvy=b.vy-a.vy; let vn=rvx*nx + rvy*ny; if(vn>0) return;
      const j=-(1+rest)*vn/(1/a.mass + 1/b.mass); const ix=j*nx, iy=j*ny; a.vx-=ix/a.mass; a.vy-=iy/a.mass; b.vx+=ix/b.mass; b.vy+=iy/b.mass;
    }

    // Drawing
    function drawHex(verts, glowK){
      ctx.beginPath(); ctx.moveTo(verts[0].x, verts[0].y);
      for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
      ctx.closePath();
      ctx.fillStyle = 'rgba(122,162,255,0.04)';
      ctx.fill();
      ctx.lineWidth = 2.2 * DPR;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--hexStroke').trim() || '#a9c1ff';
      ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--hexStroke').trim() || '#a9c1ff';
      ctx.shadowBlur = 18 * DPR * glowK;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Setup & RAF
    function resyncHex(){ const {cx,cy}=center(); currentHexVerts = regularPolygon(cx, cy, params.hexRadius, 6, hexAngle); }
    function resetAll(){ balls=[]; setBallCount(Number(ui.count.value)); }
    function initial(){ applyTheme(ui.theme.value); rescaleBallSizes(); resetAll(); resyncHex(); }
    initial();

    let last=performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      const dt=Math.min(0.033,(now-last)/1000); last=now; updateFps(now);
      if(!paused){ hexAngle += params.hexRotSpeed*dt; }
      resyncHex();
      const substeps=3, subdt=dt/substeps;
      if(!paused){
        for(let s=0;s<substeps;s++){
          for(const b of balls) b.step(subdt, params);
          for(let i=0;i<balls.length;i++) for(let j=i+1;j<balls.length;j++) resolveBallBall(balls[i], balls[j], params.rest);
          for(const b of balls) collideBallWithPolygon(b, currentHexVerts, params.rest);
        }
      }
      ctx.clearRect(0,0,W,H);
      drawHex(currentHexVerts, params.glow);
      for(const b of balls) b.draw(ctx, params.overlay, params.glow);
    }
    requestAnimationFrame(loop);

    // Controls
    ui.pause.addEventListener('click', ()=>{ paused=!paused; ui.pause.textContent = paused ? 'Resume' : 'Pause'; });
    ui.reset.addEventListener('click', ()=>{ resetAll(); });
    ui.randomize.addEventListener('click', ()=>{
      ui.gravity.value = String(Math.round(rand(-600, 900)));
      ui.air.value = (Math.random()*0.02 + 0.001).toFixed(3);
      ui.rest.value = (Math.random()*0.3 + 0.8).toFixed(2);
      ui.rot.value = String(Math.round(rand(-100,100)));
      ui.radius.value = String(Math.round(rand(180, Math.min(800, Math.min(W,H)/2))));
      const minSize = Math.round(rand(15, 33));
      const maxSize = Math.round(rand(minSize, 40));
      ui.minr.value = String(minSize); ui.maxr.value = String(maxSize);
      ['gravity','air','rest','rot','radius','minr','maxr','glow'].forEach(id=> ui[id].dispatchEvent(new Event('input')));
      resetAll();
    });

    // Keyboard
    const overlays = ['off','numbers','faces','velocity'];
    window.addEventListener('keydown', e=>{
      if(e.key===' '){ e.preventDefault(); ui.pause.click(); }
      if(e.key.toLowerCase()==='r') ui.reset.click();
      if(e.key.toLowerCase()==='l'){
        const idx = overlays.indexOf(ui.overlay.value);
        ui.overlay.value = overlays[(idx+1)%overlays.length];
        ui.overlay.dispatchEvent(new Event('change'));
      }
    });
  </script>
</body>
</html>